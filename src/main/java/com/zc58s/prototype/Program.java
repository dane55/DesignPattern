package com.zc58s.prototype;

import java.io.IOException;

/*
 * 概述：
 * 浅复制、深度复制
 * 原型：
 * 在开发中，引用类型的传递仅仅是传递地址，但是有时候我们需要复制一个一模一样的对象，并且他们之间的操作相互不影响，
 * 此时就需要用到原型模式。
 * 在.NET中，这个原型模式已经集成到框架中了，Java中Object里面倒是有Clone方法，但是是受保护的方法，需要内自己取调用。
 * 但是，假如在外部需要使用到对象的原型对象，需要再声明一个public的clone方法。
 * 浅复制：
 *  1、对于值类型以及Sting类型是值传递，属性变化后，前后互不影响；
 *  2、如果是对象，那对不起，虽然复制的是一份引用，指针扔指向的原来那个地址。
 * 深复制：
 *  创建一个全新的对象，虽然值和当前对象一直，已经他不再是他了。
 * 要了解这个内存分配，需要了解堆栈？
 * 栈：
 * 首先要明白这玩意儿是由操作系统来分配的，有一个1+1=2的运算，简单来讲操作系统先声明的两个等于1的变量，
 * 然后再声明一个变量将结果赋值为2，后把两个1的变量删除，这个就值传递，那么此时再来看浅复制，就很好理解
 * 属性的值之间相互不影响。
 * 堆：
 * 程序员来分配的内存，在栈里面存储了内存地址，浅复制执行后，这个栈指向的内存地址是没有变的，所以引用对象
 * 被修改后，两个对象同步变化。
 *
 * @author      : fjc.dane@gmail.com
 * @create time : 2020/11/20 16:23
 */
public class Program extends Object {

    public static void main(String[] args) {


    }
}
